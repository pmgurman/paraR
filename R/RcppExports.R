# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

par_cor_vecs <- function(x, y, threads = 1L) {
    .Call('_paraR_par_cor_vecs', PACKAGE = 'paraR', x, y, threads)
}

par_cor_matrix <- function(X, threads = 1L) {
    .Call('_paraR_par_cor_matrix', PACKAGE = 'paraR', X, threads)
}

par_col_cors <- function(X, Y, threads = 1L) {
    .Call('_paraR_par_col_cors', PACKAGE = 'paraR', X, Y, threads)
}

#' Matrix Distance Measures
#'
#' Calculate the distance bewteen matrix rows using various distance measures.
#'
#' OpenMP is used to calculate improve calculation times.
#' @param x A numeric vector
#' @param na_rm Does nothing at present.
#' @param threads The number of threads to run calculation over
#' @export
par_dist <- function(mat) {
    .Call('_paraR_par_dist', PACKAGE = 'paraR', mat)
}

#' Matrix Distance Measures
#'
#' Calculate the distance bewteen matrix rows using various distance measures.
#'
#' OpenMP is used to calculate improve calculation times.
#' @param x A numeric vector
#' @param na_rm Does nothing at present.
#' @param threads The number of threads to run calculation over
#' @export
par_dist_old <- function(x, method = "euclidian", na_rm = FALSE, threads = 1L, display_progress = FALSE) {
    .Call('_paraR_par_dist_old', PACKAGE = 'paraR', x, method, na_rm, threads, display_progress)
}

Rcpp_as_numeric_matrix <- function(x) {
    .Call('_paraR_Rcpp_as_numeric_matrix', PACKAGE = 'paraR', x)
}

#' Calculate the mean of a numeric vector
#' OpenMP is used to calculate improve calculation times.
#' @param x A numeric vector
#' @param na_rm Does nothing at present.
#' @param threads The number of threads to run calculation over
#' @export
par_mean <- function(x, na_rm = FALSE) {
    .Call('_paraR_par_mean', PACKAGE = 'paraR', x, na_rm)
}

#' Calculate the column means for each column of a matrix.
#' OpenMP is used to calculate improve calculation times.
#' TODO: Needs to implement a multicore cliff.
#' @param x A numeric vector
#' @param na_rm Does nothing at present.
#' @param threads The number of threads to run calculation over
#' @export
par_colMeans <- function(mat) {
    .Call('_paraR_par_colMeans', PACKAGE = 'paraR', mat)
}

par_rank <- function(x, threads = 1L) {
    .Call('_paraR_par_rank', PACKAGE = 'paraR', x, threads)
}

#' @useDynLib paraR
#' @importFrom Rcpp sourceCpp
NULL

#' * Sort a vector using __gnu_parallel::sort.
#' * Code is not parallel, but is more efficient for numeric vectors than base R.
#' Parallel sort codes is https://gcc.gnu.org/onlinedocs/libstdc++/manual/parallel_mode_using.html
#' @param x A numeric vector
#' @export
par_sort <- function(x) {
    .Call('_paraR_par_sort', PACKAGE = 'paraR', x)
}

#' Vector and Matrix Sums
#'
#' Calculate the sum of a vector
#'
#' Calculate the sum of a numeric vector
#' OpenMP is used to calculate improve calculation times.
#' @param x A numeric vector
#' @param na_rm Does nothing at present.
#' @param threads The number of threads to run calculation over
#' @export
par_sum <- function(x, na_rm = FALSE, threads = 1L) {
    .Call('_paraR_par_sum', PACKAGE = 'paraR', x, na_rm, threads)
}

par_sum2 <- function(x, na_rm = FALSE, threads = 1L) {
    .Call('_paraR_par_sum2', PACKAGE = 'paraR', x, na_rm, threads)
}

#' Calculate the column sums for each column of a matrix.
#' OpenMP is used to calculate improve calculation times.
#' TODO: Needs to implement a multicore cliff.
#' @param x A numeric vector
#' @param na_rm Does nothing at present.
#' @param threads The number of threads to run calculation over
#' @export
par_colSums <- function(x, na_rm = FALSE, threads = 1L, display_progress = FALSE) {
    .Call('_paraR_par_colSums', PACKAGE = 'paraR', x, na_rm, threads, display_progress)
}

#' Calculate the column sums for each column of a matrix.
#' OpenMP is used to calculate improve calculation times.
#' TODO: Needs to implement a multicore cliff.
#' @param x A numeric vector
#' @param na_rm Does nothing at present.
#' @param threads The number of threads to run calculation over
#' @export
par_colSums2 <- function(x, na_rm = FALSE, threads = 1L, display_progress = FALSE) {
    .Call('_paraR_par_colSums2', PACKAGE = 'paraR', x, na_rm, threads, display_progress)
}

#' Calculate the varance of a vector.
#' Currently uses the Rcpp sugar implementation of the variance function.
#' TODO: Needs to implement a multicore cliff.
#' Based on https://en.wikipedia.org/wiki/Algorithms_for_calculating_variance
#' @param x A numeric vector
#' @export
par_var <- function(x, na_rm = FALSE, threads = 1L) {
    .Call('_paraR_par_var', PACKAGE = 'paraR', x, na_rm, threads)
}

#' Calculate the column variances of a matrix
#' * OpenMP is used to calculate improve calculation times.
#' TODO: Needs to implement a multicore cliff.
#' @param x A numeric vector
#' @param na_rm Does nothing at present.
#' @param threads The number of threads to run calculation over
#' @export
par_colVars <- function(x, na_rm = FALSE, threads = 1L) {
    .Call('_paraR_par_colVars', PACKAGE = 'paraR', x, na_rm, threads)
}

